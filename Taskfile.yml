version: "3"

vars:
  VERSION:
    sh: echo "${VERSION:-$(git describe --tags --always --abbrev=0 --match='v[0-9]*.[0-9]*.[0-9]*' 2> /dev/null | sed 's/^.//' || echo 'dev')}"
  COMMIT_HASH:
    sh: echo "${COMMIT_HASH:-$(git rev-parse --short HEAD 2>/dev/null || echo 'unknown')}"
  BUILD_DATE:
    sh: echo "${BUILD_DATE:-$(date '+%Y-%m-%dT%H:%M:%S')}"
  LD_FLAGS:
    sh: echo "-X main.Version={{.VERSION}} -X main.CommitHash={{.COMMIT_HASH}} -X main.BuildTimestamp={{.BUILD_DATE}}"

tasks:
  build:
    desc: Build the wombat runtime
    cmds:
      - go mod tidy
      - go build -tags "{{.TAGS}}" -ldflags="{{.LD_FLAGS}}" -o ./target/connect-runtime-wombat *.go

  test:
    desc: Run all tests (excluding stress tests)
    cmds:
      - go run github.com/onsi/ginkgo/v2/ginkgo -r --compilers=4 --skip-package=stress_tests

  test:nats:
    desc: Run NATS component tests (integration, benchmark, stress)
    cmds:
      - ./test/run_nats_tests.sh

  test:integration:
    desc: Run integration tests
    cmds:
      - go run github.com/onsi/ginkgo/v2/ginkgo -p -v ./test/integration

  test:benchmark:
    desc: Run performance benchmarks
    cmds:
      - go test -run=^$ -bench=BenchmarkSimple -benchmem ./test/benchmark -benchtime=10x

  test:benchmark:full:
    desc: Run all performance benchmarks (takes longer)
    cmds:
      - go test -run=^$ -bench=. -benchmem ./test/benchmark -benchtime=3x

  test:stress:
    desc: Run stress tests
    cmds:
      - go run github.com/onsi/ginkgo/v2/ginkgo -p -v ./stress_tests

  test:coverage:
    desc: Run tests with coverage report
    cmds:
      - go test -coverprofile=coverage.out -covermode=atomic ./...
      - go tool cover -html=coverage.out -o coverage.html
      - echo "Coverage report generated at coverage.html"
      - 'go tool cover -func=coverage.out | grep total | awk ''{print "Total coverage: " $3}'''

  lint:
    desc: Run golangci-lint
    cmds:
      - golangci-lint run ./... --timeout=10m


  lint:install:
    desc: Install golangci-lint
    cmds:
      - go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

  fmt:
    desc: Format all Go code
    cmds:
      - go fmt ./...

  fmt:check:
    desc: Check if code is formatted
    cmds:
      - test -z "$(gofmt -l .)" || (echo "Code is not formatted. Run 'task fmt' to fix." && exit 1)

  quality:
    desc: Run all quality checks (format, lint, test)
    cmds:
      - task: fmt:check
      - task: lint
      - task: test

  quality:warn:
    desc: Run all quality checks with non-failing lint
    cmds:
      - task: fmt:check
      - cmd: golangci-lint run ./... --timeout=5m || true
        silent: false
      - task: test

  test:crawl:
    cmds:
      - nats kv add TMP > /dev/null
      - defer: nats kv del --force TMP
      - cd ../connect-node && go run ./cmd/connect-node crawl ../connect-runtime-wombat --bucket=TMP

  validate:
    cmds:
      - curl --silent https://raw.githubusercontent.com/synadia-io/connect/refs/heads/main/model/schemas/component-spec-v1.schema.json -O
      - npx --yes ajv-cli validate -s component-spec-v1.schema.json -d ".connect/*/*.yml" --verbose

  validate_dir:
    requires:
      vars:
        - DIR
    cmds:
      - curl --silent https://raw.githubusercontent.com/synadia-io/connect/refs/heads/main/model/schemas/component-spec-v1.schema.json -O
      - npx --yes ajv-cli validate -s component-spec-v1.schema.json -d "{{.DIR}}/*/*.yml" --verbose

  docker:local:
    desc: Build Docker image locally with version information
    vars:
      LOCAL_VERSION:
        sh: git describe --tags --always --abbrev=0 --match='v[0-9]*.[0-9]*.[0-9]*' 2> /dev/null | sed 's/^.//' || echo "dev"
      LOCAL_COMMIT:
        sh: git rev-parse --short HEAD 2>/dev/null || echo "unknown"
      LOCAL_DATE:
        sh: date '+%Y-%m-%dT%H:%M:%S'
    cmds:
      - docker build --no-cache -t connect-runtime-wombat:local --build-arg VERSION={{.LOCAL_VERSION}} --build-arg COMMIT_HASH={{.LOCAL_COMMIT}} --build-arg BUILD_DATE={{.LOCAL_DATE}} .

  # Do not edit. Shared with wombatwisdom/components.
  setup:
    desc: Setup development environment
    cmds:
      - go install github.com/goreleaser/goreleaser/v2@latest
      - go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@latest
  check:
    desc: Run all code quality checks
    cmds:
      - task: lint
      - task: format:check
  format:check:
    desc: Check code formatting
    cmds:
      - |
        if [ -n "$(gofmt -l .)" ]; then
          echo "Code is not formatted. Please run 'task fmt'"
          gofmt -l .
          exit 1
        fi
  release:snapshot:
    desc: Create a local snapshot release (no tags)
    env:
      GITHUB_REPOSITORY_OWNER: wombatwisdom
    cmds:
      - goreleaser release --snapshot --clean --skip=publish,docker
  release:check:
    desc: Pre-release checks
    cmds:
      - |
        # Check for uncommitted changes
        if [ -n "$(git status --porcelain)" ]; then
          echo "Error: Uncommitted changes detected. Please commit or stash changes before releasing."
          exit 1
        fi
      - |
        # Check we're on main branch
        BRANCH=$(git rev-parse --abbrev-ref HEAD)
        if [ "$BRANCH" != "main" ]; then
          echo "Error: Releases must be created from main branch. Currently on: $BRANCH"
          exit 1
        fi
      - |
        # Ensure we have latest changes
        git fetch origin main
        if [ $(git rev-list HEAD...origin/main --count) -gt 0 ]; then
          echo "Error: Local main branch is not up to date with origin. Please pull latest changes."
          exit 1
        fi



  release:rc:
    desc: Create a release candidate
    vars:
      CURRENT_TAG:
        sh: git describe --tags --always --abbrev=0 --match='v[0-9]*.[0-9]*.[0-9]*' 2>/dev/null || echo "v0.0.0"
      NEXT_RC:
        sh: |
          # Get the most recent tag
          current_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")

          # If no tags exist and we got a commit hash, use v0.0.0
          if ! echo "$current_tag" | grep -q '^v[0-9]'; then
            current_tag="v0.0.0"
          fi

          if echo "$current_tag" | grep -q "\-rc"; then
            # Extract base version and RC number
            base=$(echo "$current_tag" | sed 's/-rc.*//')
            rc_num=$(echo "$current_tag" | sed 's/.*-rc//')
            next_rc=$((rc_num + 1))
            echo "${base}-rc${next_rc}" | sed 's/^v//'
          else
            # No RC suffix, increment patch version for new RC series
            version=$(echo "$current_tag" | sed 's/^v//')
            major=$(echo "$version" | cut -d. -f1)
            minor=$(echo "$version" | cut -d. -f2)
            patch=$(echo "$version" | cut -d. -f3)

            # Increment patch version
            next_patch=$((patch + 1))
            echo "${major}.${minor}.${next_patch}-rc1"
          fi
      TAG_VERSION: "v{{.NEXT_RC}}"
    cmds:
      - task: release:check
      - task: check
      - task: test
      - |
        echo "Creating release candidate: {{.TAG_VERSION}}"

        # Validate version format
        if ! echo "{{.NEXT_RC}}" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+(-rc[0-9]+)?$'; then
          echo "Error: Invalid version format. Expected: X.Y.Z or X.Y.Z-rcN"
          exit 1
        fi

        # Check that runtime.yml default_version matches the tag we're about to create
        RUNTIME_VERSION=$(grep "^default_version:" .connect/runtime.yml | awk '{print $2}' | tr -d '"' | tr -d "'")
        if [ "$RUNTIME_VERSION" != "{{.TAG_VERSION}}" ]; then
          echo "Error: Version mismatch!"
          echo "  runtime.yml default_version: $RUNTIME_VERSION"
          echo "  Tag to be created: {{.TAG_VERSION}}"
          echo ""
          echo "Please update .connect/runtime.yml default_version to {{.TAG_VERSION}} before creating the release."
          exit 1
        fi

        # Check if tag already exists
        if git rev-parse "{{.TAG_VERSION}}" >/dev/null 2>&1; then
          echo "Error: Tag {{.TAG_VERSION}} already exists"
          exit 1
        fi

        # Create and push tag
        git tag -a "{{.TAG_VERSION}}" -m "Release candidate {{.TAG_VERSION}}"
        git push origin "{{.TAG_VERSION}}"

        echo "✅ Tag {{.TAG_VERSION}} created and pushed"
        echo "GitHub Actions will now create the release using goreleaser"

  release:final:
    desc: Create a final release
    vars:
      CURRENT_TAG:
        sh: git describe --tags --always --abbrev=0 --match='v[0-9]*.[0-9]*.[0-9]*' 2>/dev/null || echo "v0.0.0"
      FINAL_VERSION:
        sh: |
          current_tag=$(git describe --tags --always --abbrev=0 --match='v[0-9]*.[0-9]*.[0-9]*' 2>/dev/null || echo "v0.0.0")
          # Remove RC suffix if present
          echo "$current_tag" | sed 's/-rc.*//' | sed 's/^v//'
      TAG_VERSION: "v{{.FINAL_VERSION}}"
    cmds:
      - task: release:check
      - task: check
      - task: test
      - |
        echo "Creating final release: {{.TAG_VERSION}}"

        # Validate version format (no RC suffix allowed)
        if ! echo "{{.FINAL_VERSION}}" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
          echo "Error: Invalid version format. Expected: X.Y.Z (no RC suffix)"
          exit 1
        fi

        # Check that runtime.yml default_version matches the tag we're about to create
        RUNTIME_VERSION=$(grep "^default_version:" .connect/runtime.yml | awk '{print $2}' | tr -d '"' | tr -d "'")
        if [ "$RUNTIME_VERSION" != "{{.TAG_VERSION}}" ]; then
          echo "Error: Version mismatch!"
          echo "  runtime.yml default_version: $RUNTIME_VERSION"
          echo "  Tag to be created: {{.TAG_VERSION}}"
          echo ""
          echo "Please update .connect/runtime.yml default_version to {{.TAG_VERSION}} before creating the release."
          exit 1
        fi

        # Check if tag already exists
        if git rev-parse "{{.TAG_VERSION}}" >/dev/null 2>&1; then
          echo "Error: Tag {{.TAG_VERSION}} already exists"
          exit 1
        fi

        # Create and push tag
        git tag -a "{{.TAG_VERSION}}" -m "Release {{.TAG_VERSION}}"
        git push origin "{{.TAG_VERSION}}"

        echo "✅ Tag {{.TAG_VERSION}} created and pushed"
        echo "GitHub Actions will now create the release using goreleaser"

  release:list:
    desc: List recent releases
    cmds:
      - gh release list --limit 20
  release:current:
    desc: Show current version
    cmds:
      - |
        CURRENT=$(git describe --tags --abbrev=0 --match="v*" 2>/dev/null || echo "v0.0.0")
        echo "Current version: $CURRENT"
        
        # Check if there are commits since last tag
        if [ "$CURRENT" != "v0.0.0" ]; then
          COMMITS_SINCE=$(git rev-list --count $CURRENT..HEAD)
          if [ $COMMITS_SINCE -gt 0 ]; then
            echo "Commits since $CURRENT: $COMMITS_SINCE"
          fi
        fi