// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package model

import "encoding/json"
import "fmt"
import "reflect"
import "regexp"

type AuthorSpec struct {
	// The email address of the author
	Email *string `json:"email,omitempty" yaml:"email,omitempty" mapstructure:"email,omitempty"`

	// The name of the author
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The url to a website related to the author
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in AuthorSpec: required")
	}
	type Plain AuthorSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AuthorSpec(plain)
	return nil
}

type ComponentKindSpec string

const ComponentKindSpecScanner ComponentKindSpec = "scanner"
const ComponentKindSpecSink ComponentKindSpec = "sink"
const ComponentKindSpecSource ComponentKindSpec = "source"

var enumValues_ComponentKindSpec = []interface{}{
	"source",
	"sink",
	"scanner",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentKindSpec) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ComponentKindSpec {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ComponentKindSpec, v)
	}
	*j = ComponentKindSpec(v)
	return nil
}

type ComponentSpec struct {
	// A description of the component
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// Fields corresponds to the JSON schema field "fields".
	Fields []FieldSpec `json:"fields,omitempty" yaml:"fields,omitempty" mapstructure:"fields,omitempty"`

	// The URL path to the icon. Can be a data: URL.
	Icon *string `json:"icon,omitempty" yaml:"icon,omitempty" mapstructure:"icon,omitempty"`

	// A human readable label for the component
	Label string `json:"label" yaml:"label" mapstructure:"label"`

	// The name of the component. This field can only contain alphanumeric characters
	// and underscores
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Status corresponds to the JSON schema field "status".
	Status ComponentStatusSpec `json:"status" yaml:"status" mapstructure:"status"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in ComponentSpec: required")
	}
	if _, ok := raw["label"]; raw != nil && !ok {
		return fmt.Errorf("field label in ComponentSpec: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ComponentSpec: required")
	}
	if _, ok := raw["status"]; raw != nil && !ok {
		return fmt.Errorf("field status in ComponentSpec: required")
	}
	type Plain ComponentSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[a-zA-Z0-9_]*$`, string(plain.Name)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", `^[a-zA-Z0-9_]*$`, "Name")
	}
	*j = ComponentSpec(plain)
	return nil
}

type ComponentStatusSpec string

const ComponentStatusSpecDeprecated ComponentStatusSpec = "deprecated"
const ComponentStatusSpecExperimental ComponentStatusSpec = "experimental"
const ComponentStatusSpecPreview ComponentStatusSpec = "preview"
const ComponentStatusSpecStable ComponentStatusSpec = "stable"

var enumValues_ComponentStatusSpec = []interface{}{
	"stable",
	"preview",
	"experimental",
	"deprecated",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentStatusSpec) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ComponentStatusSpec {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ComponentStatusSpec, v)
	}
	*j = ComponentStatusSpec(v)
	return nil
}

type ConstraintSpec struct {
	// Enum corresponds to the JSON schema field "enum".
	Enum []string `json:"enum,omitempty" yaml:"enum,omitempty" mapstructure:"enum,omitempty"`

	// A preset which implies the rules to which the value must adhere
	Preset *string `json:"preset,omitempty" yaml:"preset,omitempty" mapstructure:"preset,omitempty"`

	// Range corresponds to the JSON schema field "range".
	Range *RangeSpec `json:"range,omitempty" yaml:"range,omitempty" mapstructure:"range,omitempty"`

	// A regular expression that the value must match
	Regex *string `json:"regex,omitempty" yaml:"regex,omitempty" mapstructure:"regex,omitempty"`
}

type FieldSpec struct {
	// Constraints corresponds to the JSON schema field "constraints".
	Constraints []ConstraintSpec `json:"constraints,omitempty" yaml:"constraints,omitempty" mapstructure:"constraints,omitempty"`

	// The default value of the field
	Default interface{} `json:"default,omitempty" yaml:"default,omitempty" mapstructure:"default,omitempty"`

	// A description of the field
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Examples corresponds to the JSON schema field "examples".
	Examples []interface{} `json:"examples,omitempty" yaml:"examples,omitempty" mapstructure:"examples,omitempty"`

	// Fields corresponds to the JSON schema field "fields".
	Fields []*FieldSpec `json:"fields,omitempty" yaml:"fields,omitempty" mapstructure:"fields,omitempty"`

	// The kind of the field
	Kind FieldSpecKind `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// A human readable label for the field
	Label string `json:"label" yaml:"label" mapstructure:"label"`

	// The name of the field. This field can only contain alphanumeric characters and
	// underscores
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// If true, the field is optional
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`

	// The path to the field in the resulting configuration. If no path is provided,
	// the field is assumed to be a grouping of other fields
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// A hint to the renderer on how to render the field
	RenderHint *string `json:"render_hint,omitempty" yaml:"render_hint,omitempty" mapstructure:"render_hint,omitempty"`

	// If true, the value of the field is considered secret and should not be
	// displayed in logs or UIs
	Secret *bool `json:"secret,omitempty" yaml:"secret,omitempty" mapstructure:"secret,omitempty"`

	// The type of the field
	Type FieldSpecType `json:"type" yaml:"type" mapstructure:"type"`
}

type FieldSpecKind string

const FieldSpecKindList FieldSpecKind = "list"
const FieldSpecKindMap FieldSpecKind = "map"
const FieldSpecKindScalar FieldSpecKind = "scalar"

var enumValues_FieldSpecKind = []interface{}{
	"scalar",
	"map",
	"list",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FieldSpecKind) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_FieldSpecKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_FieldSpecKind, v)
	}
	*j = FieldSpecKind(v)
	return nil
}

type FieldSpecType string

const FieldSpecTypeBool FieldSpecType = "bool"
const FieldSpecTypeCondition FieldSpecType = "condition"
const FieldSpecTypeExpression FieldSpecType = "expression"
const FieldSpecTypeInt FieldSpecType = "int"
const FieldSpecTypeObject FieldSpecType = "object"
const FieldSpecTypeScanner FieldSpecType = "scanner"
const FieldSpecTypeString FieldSpecType = "string"

var enumValues_FieldSpecType = []interface{}{
	"bool",
	"int",
	"object",
	"scanner",
	"string",
	"expression",
	"condition",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FieldSpecType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_FieldSpecType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_FieldSpecType, v)
	}
	*j = FieldSpecType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FieldSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["label"]; raw != nil && !ok {
		return fmt.Errorf("field label in FieldSpec: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in FieldSpec: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in FieldSpec: required")
	}
	type Plain FieldSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		plain.Kind = "scalar"
	}
	if matched, _ := regexp.MatchString(`^[a-zA-Z0-9_]*$`, string(plain.Name)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", `^[a-zA-Z0-9_]*$`, "Name")
	}
	*j = FieldSpec(plain)
	return nil
}

type MetricsSpec struct {
	// The path where metrics can be retrieved
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// The port number where metrics can be retrieved
	Port int `json:"port" yaml:"port" mapstructure:"port"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MetricsSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["port"]; raw != nil && !ok {
		return fmt.Errorf("field port in MetricsSpec: required")
	}
	type Plain MetricsSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MetricsSpec(plain)
	return nil
}

type RangeSpec struct {
	// If filled in, the value must be greater than this
	Gt *float64 `json:"gt,omitempty" yaml:"gt,omitempty" mapstructure:"gt,omitempty"`

	// If filled in, the value must be greater than or equal to this
	Gte *float64 `json:"gte,omitempty" yaml:"gte,omitempty" mapstructure:"gte,omitempty"`

	// If filled in, the value must be less than this
	Lt *float64 `json:"lt,omitempty" yaml:"lt,omitempty" mapstructure:"lt,omitempty"`

	// If filled in, the value must be less than or equal to this
	Lte *float64 `json:"lte,omitempty" yaml:"lte,omitempty" mapstructure:"lte,omitempty"`
}

type RuntimeSpec struct {
	// Author corresponds to the JSON schema field "author".
	Author AuthorSpec `json:"author" yaml:"author" mapstructure:"author"`

	// A description of the runtime
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// The image of the runtime
	Image string `json:"image" yaml:"image" mapstructure:"image"`

	// A human readable label for the runtime
	Label string `json:"label" yaml:"label" mapstructure:"label"`

	// Metrics corresponds to the JSON schema field "metrics".
	Metrics *MetricsSpec `json:"metrics,omitempty" yaml:"metrics,omitempty" mapstructure:"metrics,omitempty"`

	// The unique identifier of the runtime
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RuntimeSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["author"]; raw != nil && !ok {
		return fmt.Errorf("field author in RuntimeSpec: required")
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in RuntimeSpec: required")
	}
	if _, ok := raw["image"]; raw != nil && !ok {
		return fmt.Errorf("field image in RuntimeSpec: required")
	}
	if _, ok := raw["label"]; raw != nil && !ok {
		return fmt.Errorf("field label in RuntimeSpec: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in RuntimeSpec: required")
	}
	type Plain RuntimeSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RuntimeSpec(plain)
	return nil
}
